articl describ approach solv problem find lca two node tree reduc rmq problem 
lowest common ancestor lca two node u v root tree defin node locat farthest root u v descend 
exampl diagram lca node 4 node 9 node 2 mani approach solv lca problem 
approach differ time space complex 
link coupl involv reduct rmq 
rang minimum queri rmq use array find posit element minimum valu two specifi indic 
differ approach solv rmq discuss 
articl segment tree base approach discuss 
segment tree preprocess time n time rang minimum queri logn 
extra space requir n store segment tree 
reduct lca rmq idea travers tree start root euler tour travers without lift pencil df type travers preorder travers characterist 
observ lca node 4 9 node 2 happen node closest root amongst encount visit 4 9 df observ key reduct 
let rephras node node smallest level node level amongst node occur consecut occurr u v euler tour requir three array implement node visit order euler tour level node visit euler tour index first occurr node euler tour sinc occurr would good let track first one algorithm euler tour tree fill euler level first occurr array 
use first occurr array get indic correspond two node corner rang level array fed rmq algorithm minimum valu 
algorithm return index minimum level rang use determin lca use euler tour array 
implement algorithm 
c c program find lca u v reduc problem rmq includ bit stdc h defin v 9 number node input tree int euler 2 v 1 euler tour sequenc int level 2 v 1 level node tour sequenc int firstoccurr v 1 first occur node tour int ind variabl fill euler level array binari tree node struct node int key struct node left right util function creat new binari tree node given key node newnod int k node temp new node temp key k temp left temp right null return temp log base 2 x int log2 int x int an 0 x 1 an return an recurs function get minimum valu given rang array index 
follow paramet function 
st pointer segment tree index index current node segment tree 
initi 0 pass root alway index 0 ss se start end index segment repres current node e st index qs qe start end index queri rang int rmqutil int index int ss int se int qs int qe int st segment node part given rang return min segment qs ss qe se return st index segment node outsid given rang els se qs ss qe return 1 part segment overlap given rang int mid ss se 2 int q1 rmqutil 2 index 1 ss mid qs qe st int q2 rmqutil 2 index 2 mid 1 se qs qe st q1 1 return q2 els q2 1 return q1 return level q1 level q2 
q1 q2 return minimum element rang index qs quey start qe queri end 
mainli use rmqutil int rmq int st int n int qs int qe check erron input valu qs 0 qe n 1 qs qe printf invalid input return 1 return rmqutil 0 0 n 1 qs qe st recurs function construct segment tree array ss se 
si index current node segment tree st void constructstutil int si int ss int se int arr int st one element array store current node segment tree return ss se st si ss els one element recur left right subtre store minimum two valu node int mid ss se 2 constructstutil si 2 1 ss mid arr st constructstutil si 2 2 mid 1 se arr st arr st 2 si 1 arr st 2 si 2 st si st 2 si 1 els st si st 2 si 2 function construct segment tree given array 
function alloc memori segment tree call constructstutil fill alloc memori int constructst int arr int n alloc memori segment tree height segment tree int x log2 n 1 maximum size segment tree int max_siz 2 1 x 1 2 pow 2 x 1 int st new int max_siz fill alloc memori st constructstutil 0 0 n 1 arr st return construct segment tree return st recurs version euler tour void eulertour node root int l pass node exist root euler ind root key insert euler array level ind l insert l level array ind increment index unvisit mark first occurr firstoccurr root key 1 firstoccurr root key ind 1 tour left subtre exist remark euler level array parent return root left eulertour root left l 1 euler ind root key level ind l ind tour right subtre exist remark euler level array parent return root right eulertour root right l 1 euler ind root key level ind l ind return lca node n1 n2 assum present tree int findlca node root int u int v mark node unvisit 
note size firstoccurr 1 node valu vari 1 9 use index memset firstoccurr 1 sizeof int v 1 start fill euler level array index 0 ind 0 start euler tour root node level 0 eulertour root 0 construct segment tree level array int st constructst level 2 v 1 v u euler tour 
rmq work first paramet u must smaller second v firstoccurr u firstoccurr v std swap u v start end index queri rang int qs firstoccurr u int qe firstoccurr v queri index lca tour int index rmq st 2 v 1 qs qe return lca node return euler index driver program test function int main let us creat binari tree shown diagram 
node root newnod 1 root left newnod 2 root right newnod 3 root left left newnod 4 root left right newnod 5 root right left newnod 6 root right right newnod 7 root left right left newnod 8 root left right right newnod 9 int u 4 v 9 printf lca node node node n u v findlca root u v return 0 java java program find lca u v reduc problem rmq import java util 
binari tree node class node node left right int data node int item data item left right null class st_class int st int stt new int 10000 class binarytre node root int v 9 v highest valu node tree int euler new int 2 v 1 euler tour sequenc int level new int 2 v 1 level node tour sequenc int f_occur new int 2 v 1 store 1st occur node int fill variabl fill euler level array st_class sc new st_class log base 2 x int log2 int x int an 0 int x 1 0 an return an int swap int int b return recurs function get minimum valu given rang array index 
follow paramet function 
st pointer segment tree index index current node segment tree 
initi 0 pass root alway index 0 ss se start end index segment repres current node e st index qs qe start end index queri rang int rmqutil int index int ss int se int qs int qe st_class st segment node part given rang return min segment qs ss qe se return st stt index segment node outsid given rang els se qs ss qe return 1 part segment overlap given rang int mid ss se 2 int q1 rmqutil 2 index 1 ss mid qs qe st int q2 rmqutil 2 index 2 mid 1 se qs qe st q1 1 return q2 els q2 1 return q1 return level q1 level q2 
q1 q2 return minimum element rang index qs quey start qe queri end 
mainli use rmqutil int rmq st_class st int n int qs int qe check erron input valu qs 0 qe n 1 qs qe system println invalid input return 1 return rmqutil 0 0 n 1 qs qe st recurs function construct segment tree array ss se 
si index current node segment tree st void constructstutil int si int ss int se int arr st_class st one element array store current node segment tree return ss se st stt si ss els one element recur left right subtre store minimum two valu node int mid ss se 2 constructstutil si 2 1 ss mid arr st constructstutil si 2 2 mid 1 se arr st arr st stt 2 si 1 arr st stt 2 si 2 st stt si st stt 2 si 1 els st stt si st stt 2 si 2 function construct segment tree given array 
function alloc memori segment tree call constructstutil fill alloc memori int constructst int arr int n alloc memori segment tree height segment tree int x log2 n 1 maximum size segment tree int max_siz 2 1 x 1 2 pow 2 x 1 sc stt new int max_siz fill alloc memori st constructstutil 0 0 n 1 arr sc return construct segment tree return sc st recurs version euler tour void eulertour node node int l pass node exist node null euler fill node data insert euler array level fill l insert l level array fill increment index unvisit mark first occurr f_occur node data 1 f_occur node data fill 1 tour left subtre exist remark euler level array parent return node left null eulertour node left l 1 euler fill node data level fill l fill tour right subtre exist remark euler level array parent return node right null eulertour node right l 1 euler fill node data level fill l fill return lca node n1 n2 assum present tree int findlca node node int u int v mark node unvisit 
note size firstoccurr 1 node valu vari 1 9 use index array fill f_occur 1 start fill euler level array index 0 fill 0 start euler tour root node level 0 eulertour root 0 construct segment tree level array sc st constructst level 2 v 1 v u euler tour 
rmq work first paramet u must smaller second v f_occur u f_occur v u swap u u v start end index queri rang int qs f_occur u int qe f_occur v queri index lca tour int index rmq sc 2 v 1 qs qe return lca node return euler index driver program test function public static void main string arg binarytre tree new binarytre let us creat binari tree shown diagram 
tree root new node 1 tree root left new node 2 tree root right new node 3 tree root left left new node 4 tree root left right new node 5 tree root right left new node 6 tree root right right new node 7 tree root left right left new node 8 tree root left right right new node 9 int u 4 v 9 system println lca node u v tree findlca tree root u v code contribut mayank jaiswal output lca node 4 node 9 node 2 note assum node queri present tree 
also assum v node tree key data node rang 1 v time complex euler tour number node v tree e v 1 
euler tour df take v e 2 v written v 
segment tree construct n n v e 2 v 1 rang minimum queri log n overal method take n time preprocss take log n time queri 
therefor use singl tree want perform larg number lca queri note lca use find shortest path two node binari tree auxiliari space euler tour array n n 2 v 1 node level array n first occurr array v segment tree n overal n anoth observ adjac element level array differ 1 use convert rmq problem lca problem 
articl contribut yash varyani 
pleas write comment find anyth incorrect want share inform topic discuss adsbygoogl window adsbygoogl push compani wise code practic topic wise code practic 
