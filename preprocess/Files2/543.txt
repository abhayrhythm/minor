recommend refer follow post prerequisit post 
b tree set 1 introduct b tree set 2 insert b tree type multi way search tree 
familiar multi way search tree gener better take look video lectur iit delhi proceed 
get basic multi way search tree clear b tree oper easier understand 
sourc follow explan algorithm introduct algorithm 3rd edit clifford stein thoma h cormen charl e leiserson ronald l rivest delet process delet b tree complic insert delet key node leaf delet key intern node rearrang node children 
insert must make sure delet violat b tree properti 
ensur node get big due insert must ensur node get small delet except root allow fewer minimum number 1 key 
simpl insert algorithm might back node path key insert full simpl approach delet might back node root along path key delet minimum number key 
delet procedur delet key k subtre root x procedur guarante whenev call recurs node x number key x least minimum degre 
note condit requir one key minimum requir usual b tree condit sometim key may move child node recurs descend child 
strengthen condit allow us delet key tree one downward pass without back one except explain 
interpret follow specif delet b tree understand root node x ever becom intern node key situat occur case 2c 3b delet x x child x c1 becom new root tree decreas height tree one preserv properti root tree contain least one key unless tree empti 
sketch delet work variou case delet key b tree 
1 key k node x x leaf delet key k x 
2 key k node x x intern node follow 
child preced k node x least key find predecessor k0 k sub tree root recurs delet k0 replac k k0 x 
find k0 delet singl downward pass 
b fewer key symmetr examin child z follow k node x z least key find successor k0 k subtre root z recurs delet k0 replac k k0 x 
find k0 delet singl downward pass 
c otherwis z 1 key merg k z x lose k pointer z contain 2t 1 key 
free z recurs delet k 
3 key k present intern node x determin root x c appropri subtre must contain k k tree 
x c 1 key execut step 3a 3b necessari guarante descend node contain least key 
finish recurs appropri child x x c 1 key immedi sibl least key give x c extra key move key x x c move key x c immedi left right sibl x move appropri child pointer sibl x c 
b x c x c immedi sibl 1 key merg x c one sibl involv move key x new merg node becom median key node 
sinc key b tree leav delet oper often use delet key leav 
recurs delet procedur act one downward pass tree without back 
delet key intern node howev procedur make downward pass tree may return node key delet replac key predecessor successor case 2a 2b 
follow figur clr book explain delet porcess 
implement follow c implement delet process 
follow program perform delet b tree 
contain function specif delet along function provid previou articl b tree 
see http www geeksforgeek org b tree set 1 introduct 2 previou articl 
delet function compartment 8 function eas understand clariti follow function exclus delet class btreenod 1 remov 2 removefromleaf 3 removefromnonleaf 4 getpr 5 getsucc 6 borrowfromprev 7 borrowfromnext 8 merg 9 findkey class btree 1 remov remov key b tree fairli complic process 
program handl 6 differ case might aris remov key 
test code test use b tree provid clr book includ main function along case 
refer clrs3 chapter 18 499 502 advis read materi clr take look code 
includ iostream use namespac std btree node class btreenod int key array key int minimum degre defin rang number key btreenod c array child pointer int n current number key bool leaf true node leaf 
otherwis fals public btreenod int _t bool _leaf constructor function travers node subtre root node void travers function search key subtre root node 
btreenod search int k return null k present 
function return index first key greater equal k int findkey int k util function insert new key subtre root node 
assumpt node must non full function call void insertnonful int k util function split child node 
index child array c 
child must full function call void splitchild int btreenod wrapper function remov key k subtre root node 
void remov int k function remov key present idx th posit node leaf void removefromleaf int idx function remov key present idx th posit node non leaf node void removefromnonleaf int idx function get predecessor key key present idx th posit node int getpr int idx function get successor key key present idx th posit node int getsucc int idx function fill child node present idx th posit c array child less 1 key void fill int idx function borrow key c idx 1 th node place c idx th node void borrowfromprev int idx function borrow key c idx 1 th node place c idx th node void borrowfromnext int idx function merg idx th child node idx 1 th child node void merg int idx make btree friend access privat member class btree function friend class btree class btree btreenod root pointer root node int minimum degre public constructor initi tree empti btree int _t root null _t void travers root null root travers function search key tree btreenod search int k return root null 
null root search k main function insert new key b tree void insert int k main function remov new key thie b tree void remov int k btreenod btreenod int t1 bool leaf1 copi given minimum degre leaf properti t1 leaf leaf1 alloc memori maximum number possibl key child pointer key new int 2 1 c new btreenod 2 initi number key 0 n 0 util function return index first key greater equal k int btreenod findkey int k int idx 0 idx n key idx k idx return idx function remov key k sub tree root node void btreenod remov int k int idx findkey k key remov present node idx n key idx k node leaf node removefromleaf call otherwis removefromnonleaf function call leaf removefromleaf idx els removefromnonleaf idx els node leaf node key present tree leaf cout key k exist tree n return key remov present sub tree root node flag indic whether key present sub tree root last child node bool flag idx n 
true fals child key suppos exist less key fill child c idx n fill idx last child merg must merg previou child recurs idx 1 th child 
els recurs idx th child atleast key flag idx n c idx 1 remov k els c idx remov k return function remov idx th key node leaf node void btreenod removefromleaf int idx move key idx th po one place backward int idx 1 n key 1 key reduc count key n return function remov idx th key node non leaf node void btreenod removefromnonleaf int idx int k key idx child preced k c idx atleast key find predecessor pred k subtre root c idx 
replac k pred 
recurs delet pred c idx c idx n int pred getpr idx key idx pred c idx remov pred child c idx less key examin c idx 1 
c idx 1 atleast key find successor succ k subtre root c idx 1 replac k succ recurs delet succ c idx 1 els c idx 1 n int succ getsucc idx key idx succ c idx 1 remov succ c idx c idx 1 less key merg k c idx 1 c idx c idx contain 2t 1 key free c idx 1 recurs delet k c idx els merg idx c idx remov k return function get predecessor key idx int btreenod getpr int idx keep move right node reach leaf btreenod cur c idx cur leaf cur cur c cur n return last key leaf return cur key cur n 1 int btreenod getsucc int idx keep move left node start c idx 1 reach leaf btreenod cur c idx 1 cur leaf cur cur c 0 return first key leaf return cur key 0 function fill child c idx less 1 key void btreenod fill int idx previou child c idx 1 1 key borrow key child idx 0 c idx 1 n borrowfromprev idx next child c idx 1 1 key borrow key child els idx n c idx 1 n borrowfromnext idx merg c idx sibl c idx last child merg previou sibl otherwis merg next sibl els idx n merg idx els merg idx 1 return function borrow key c idx 1 insert c idx void btreenod borrowfromprev int idx btreenod child c idx btreenod sibl c idx 1 last key c idx 1 goe parent key idx 1 parent insert first key c idx 
thu lose sibl one key child gain one key move key c idx one step ahead int child n 1 0 child key 1 child key c idx leaf move child pointer one step ahead child leaf int child n 0 child c 1 child c set child first key equal key idx 1 current node child key 0 key idx 1 move sibl last child c idx first child leaf child c 0 sibl c sibl n move key sibl parent reduc number key sibl key idx 1 sibl key sibl n 1 child n 1 sibl n 1 return function borrow key c idx 1 place c idx void btreenod borrowfromnext int idx btreenod child c idx btreenod sibl c idx 1 key idx insert last key c idx child key child n key idx sibl first child insert last child c idx 
child leaf child c child n 1 sibl c 0 first key sibl insert key idx key idx sibl key 0 move key sibl one step behind int 1 sibl n sibl key 1 sibl key move child pointer one step behind sibl leaf int 1 sibl n sibl c 1 sibl c increas decreas key count c idx c idx 1 respect child n 1 sibl n 1 return function merg c idx c idx 1 c idx 1 freed merg void btreenod merg int idx btreenod child c idx btreenod sibl c idx 1 pull key current node insert 1 th posit c idx child key 1 key idx copi key c idx 1 c idx end int 0 sibl n child key sibl key copi child pointer c idx 1 c idx child leaf int 0 sibl n child c sibl c move key idx current node one step fill gap creat move key idx c idx int idx 1 n key 1 key move child pointer idx 1 current node one step int idx 2 n c 1 c updat key count child current node child n sibl n 1 n free memori occupi sibl delet sibl return main function insert new key b tree void btree insert int k tree empti root null alloc memori root root new btreenod true root key 0 k insert key root n 1 updat number key root els tree empti root full tree grow height root n 2 1 alloc memori new root btreenod new btreenod fals make old root child new root c 0 root split old root move 1 key new root splitchild 0 root new root two children 
decid two children go new key int 0 key 0 k c insertnonful k chang root root els root full call insertnonful root root insertnonful k util function insert new key node assumpt node must non full function call void btreenod insertnonful int k initi index index rightmost element int n 1 leaf node leaf true follow loop two thing find locat new key insert b move greater key one place ahead 0 key k key 1 key insert new key found locat key 1 k n n 1 els node leaf find child go new key 0 key k see found child full c 1 n 2 1 child full split splitchild 1 c 1 split middl key c goe c split two 
see two go new key key 1 k c 1 insertnonful k util function split child node note must full function call void btreenod splitchild int btreenod creat new node go store 1 key btreenod z new btreenod leaf z n 1 copi last 1 key z int j 0 j 1 j z key j key j copi last children z leaf fals int j 0 j j z c j c j reduc number key n 1 sinc node go new child creat space new child int j n j 1 j c j 1 c j link new child node c 1 z key move node 
find locat new key move greater key one space ahead int j n 1 j j key j 1 key j copi middl key node key key 1 increment count key node n n 1 function travers node subtre root node void btreenod travers n key n 1 children traver n key first n children int 0 n leaf print key travers subtre root child c 
leaf fals c travers cout key print subtre root last child leaf fals c travers function search key k subtre root node btreenod btreenod search int k find first key greater equal k int 0 n k key found key equal k return node key k return key found leaf node leaf true return null go appropri child return c search k void btree remov int k root cout tree empti n return call remov function root root remov k root node 0 key make first child new root child otherwis set root null root n 0 btreenod tmp root root leaf root null els root root c 0 free old root delet tmp return driver program test function int main btree 3 b tree minium degre 3 insert 1 insert 3 insert 7 insert 10 insert 11 insert 13 insert 14 insert 15 insert 18 insert 16 insert 19 insert 24 insert 25 insert 26 insert 21 insert 4 insert 5 insert 20 insert 22 insert 2 insert 17 insert 12 insert 6 cout travers tree construct n travers cout endl remov 6 cout travers tree remov 6 n travers cout endl remov 13 cout travers tree remov 13 n travers cout endl remov 7 cout travers tree remov 7 n travers cout endl remov 4 cout travers tree remov 4 n travers cout endl remov 2 cout travers tree remov 2 n travers cout endl remov 16 cout travers tree remov 16 n travers cout endl return 0 output travers tree construct 1 2 3 4 5 6 7 10 11 12 13 14 15 16 17 18 19 20 21 22 24 25 26 travers tree remov 6 1 2 3 4 5 7 10 11 12 13 14 15 16 17 18 19 20 21 22 24 25 26 travers tree remov 13 1 2 3 4 5 7 10 11 12 14 15 16 17 18 19 20 21 22 24 25 26 travers tree remov 7 1 2 3 4 5 10 11 12 14 15 16 17 18 19 20 21 22 24 25 26 travers tree remov 4 1 2 3 5 10 11 12 14 15 16 17 18 19 20 21 22 24 25 26 travers tree remov 2 1 3 5 10 11 12 14 15 16 17 18 19 20 21 22 24 25 26 travers tree remov 16 1 3 5 10 11 12 14 15 17 18 19 20 21 22 24 25 26 articl contribut balasubramanian n 
pleas write comment find anyth incorrect want share inform topic discuss 
adsbygoogl window adsbygoogl push compani wise code practic topic wise code practic 
