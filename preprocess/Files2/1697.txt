given root binari search tree k input find k th smallest element bst 
exampl follow bst k 3 output 10 k 5 output 14 method 1 use inord travers 
inord travers bst retriev element tree sort order 
inord travers use stack store explor node tree thread tree avoid stack recurs travers see post 
idea keep track pop element particip order static 
hypothet algorithm provid time complex n n total node tree algorithm initi pcrawl root set initi stack element null sentin travers upto left extrem pcrawl valid stack push pcrawl pcrawl pcrawl left process node pcrawl stack pop valid stop suffici number element pop 
pcrawl right valid pcrawl pcrawl right pcrawl valid stack push pcrawl pcrawl pcrawl left implement includ stdio h includ stdlib h defin array_s arr sizeof arr sizeof arr 0 add element test note sort array result skew tree int ele 20 8 22 4 12 10 14 alia typedef struct node_t node_t binari tree node struct node_t int data node_t left node_t right simpl stack store node address typedef struct stack_t stack_t initi element alway null use sentin struct stack_t node_t base array_s ele 1 int stackindex pop oper stack node_t pop stack_t st node_t ret null st st stackindex 0 ret st base st stackindex st stackindex return ret push oper stack void push stack_t st node_t node st st stackindex st base st stackindex node iter insert recurs least prefer unless gain someth node_t insert_nod node_t root node_t node crawl pointer node_t ptravers root node_t currentpar root travers till appropri node ptravers currentpar ptravers node data ptravers data left subtre ptravers ptravers left els right subtre ptravers ptravers right tree empti make root node root root node els node data currentpar data insert left side currentpar left node els insert right side currentpar right node return root element array 
function build binari tree node_t binary_search_tre node_t root int key int const size int iter node_t new_nod null iter 0 iter size iter new_nod node_t malloc sizeof node_t initi new_nod data key iter new_nod left null new_nod right null insert bst root insert_nod root new_nod return root node_t k_smallest_element_inord stack_t stack node_t root int k stack_t st stack node_t pcrawl root move left extremen minimum pcrawl push st pcrawl pcrawl pcrawl left pop stack process node pcrawl pop st pop oper emit one element order k loop test st stackindex 0 break right subtre pcrawl right push left subtre right subtre pcrawl pcrawl right pcrawl push st pcrawl pcrawl pcrawl left pop stack repeat node k th element null node return pcrawl driver program test function int main void node_t root null stack_t stack 0 0 node_t knode null int k 5 creat tree given diagram root binary_search_tre root ele array_s ele knode k_smallest_element_inord stack root k knode printf kth smallest elment k k knode data els printf element getchar return 0 method 2 augment tree data structur 
idea maintain rank node 
keep track element subtre node build tree 
sinc need k th smallest element maintain number element left subtre everi node 
assum root n node left subtre 
k n 1 root k th node 
k n continu search recurs kth smallest element left subtre root 
k n 1 continu search right subtre k n 1 th smallest element 
note need count element left subtre 
time complex h h height tree 
algorithm start k root leftel 1 root node k th node 
goto stop els k root leftel k k root leftel 1 root root right goto start els root root left goto srart stop implement includ stdio h includ stdlib h defin array_s arr sizeof arr sizeof arr 0 typedef struct node_t node_t binari tree node struct node_t int data int lcount node_t left node_t right iter insert recurs least prefer unless gain someth node_t insert_nod node_t root node_t node crawl pointer node_t ptravers root node_t currentpar root travers till appropri node ptravers currentpar ptravers node data ptravers data branch left subtre increment node count ptravers lcount left subtre ptravers ptravers left els right subtre ptravers ptravers right tree empti make root node root root node els node data currentpar data insert left side currentpar left node els insert right side currentpar right node return root element array 
function build binari tree node_t binary_search_tre node_t root int key int const size int iter node_t new_nod null iter 0 iter size iter new_nod node_t malloc sizeof node_t initi new_nod data key iter new_nod lcount 0 new_nod left null new_nod right null insert bst root insert_nod root new_nod return root int k_smallest_el node_t root int k int ret 1 root crawl pointer node_t ptravers root go k th smallest ptravers ptravers lcount 1 k ret ptravers data break els k ptravers lcount less node left subtre go right subtre k k ptravers lcount 1 ptravers ptravers right els node left subtre ptravers ptravers left return ret driver program test function int main void add element test note sort array result skew tree int ele 20 8 22 4 12 10 14 int node_t root null creat tree given diagram root binary_search_tre root ele array_s ele print sort array 1 array_s ele printf n kth smallest elment k k_smallest_el root getchar return 0 thank venki provid post 
pleas write comment find anyth incorrect want share inform topic discuss 
adsbygoogl window adsbygoogl push compani wise code practic topic wise code practic 
