biconnect compon maxim biconnect subgraph 
biconnect graph alreadi discuss 
articl see find biconnect compon graph use algorithm john hopcroft robert tarjan 
graph follow biconnect compon 4 2 3 4 3 1 2 3 1 2 8 9 8 5 7 8 5 7 6 0 5 6 1 5 0 1 10 11 algorithm base disc low valu discuss strongli connect compon articl 
idea store visit edg stack df graph keep look articul point highlight figur 
soon articul point u found edg visit df node u onward form one biconnect compon 
df complet one connect compon edg present stack form biconnect compon 
articul point graph graph biconnect one biconnect compon graph 
c c program find biconnect compon given undirect graph includ iostream includ list includ stack defin nil 1 use namespac std int count 0 class edg public int u int v edg int u int v edg edg int u int v u u v v class repres direct graph class graph int v 
vertic int e 
edg list int adj dynam array adjac list recurs df base function use bcc void bccutil int u int disc int low list edg st int parent public graph int v constructor void addedg int v int w function add edg graph void bcc print strongli connect compon graph graph int v v v e 0 adj new list int v void graph addedg int v int w adj v push_back w e recurs function find print strongli connect compon use df travers u vertex visit next disc store discoveri time visit vertic low earliest visit vertex vertex minimum discoveri time reach subtre root current vertex st store visit edg void graph bccutil int u int disc int low list edg st int parent static variabl use simplic avoid use static variabl pass pointer 
static int time 0 initi discoveri time low valu disc u low u time int children 0 go vertic adjac list int iter adj u begin adj u end int v v current adjac u v visit yet recur disc v 1 children parent v u store edg stack st push_back edg u v bccutil v disc low st parent check subtre root v connect one ancestor u case 1 per strongli connect compon articl low u min low u low v u articul point pop edg stack till u v disc u 1 children 1 disc u 1 low v disc u st back u u st back v v cout st back u st back v st pop_back cout st back u st back v st pop_back cout endl count updat low valu u v still stack e 
back edg cross edg 
case 2 per strongli connect compon articl els v parent u disc v low u low u min low u disc v st push_back edg u v function df travers 
use bccutil void graph bcc int disc new int v int low new int v int parent new int v list edg st new list edg e initi disc low parent array int 0 v disc nil low nil parent nil int 0 v disc nil bccutil disc low st parent int j 0 stack empti pop edg stack st size 0 j 1 cout st back u st back v st pop_back j 1 cout endl count driver program test function int main graph g 12 g addedg 0 1 g addedg 1 0 g addedg 1 2 g addedg 2 1 g addedg 1 3 g addedg 3 1 g addedg 2 3 g addedg 3 2 g addedg 2 4 g addedg 4 2 g addedg 3 4 g addedg 4 3 g addedg 1 5 g addedg 5 1 g addedg 0 6 g addedg 6 0 g addedg 5 6 g addedg 6 5 g addedg 5 7 g addedg 7 5 g addedg 5 8 g addedg 8 5 g addedg 7 8 g addedg 8 7 g addedg 8 9 g addedg 9 8 g addedg 10 11 g addedg 11 10 g bcc cout count biconnect compon graph return 0 java java program find biconnect compon given undirect graph import java io 
import java util 
class repres direct graph use adjac list represent class graph privat int v e 
vertic edg respect privat linkedlist integ adj adjac list count number biconnect compon 
time use find discoveri time static int count 0 time 0 class edg int u int v edg int u int v u u v v constructor graph int v v v e 0 adj new linkedlist v int 0 v adj new linkedlist function add edg graph void addedg int v int w adj v add w e recurs function find print strongli connect compon use df travers u vertex visit next disc store discoveri time visit vertic low earliest visit vertex vertex minimum discoveri time reach subtre root current vertex st store visit edg void bccutil int u int disc int low linkedlist edg st int parent initi discoveri time low valu disc u low u time int children 0 go vertic adjac iter integ adj u iter hasnext int v next v current adjac u v visit yet recur disc v 1 children parent v u store edg stack st add new edg u v bccutil v disc low st parent check subtre root v connect one ancestor u case 1 per strongli connect compon articl low u low v low u low v u articul point pop edg stack till u v disc u 1 children 1 disc u 1 low v disc u st getlast u u st getlast v v system print st getlast u st getlast v st removelast system println st getlast u st getlast v st removelast count updat low valu u v still stack e 
back edg cross edg 
case 2 per strongli connect compon articl els v parent u disc v low u low u disc v low u disc v st add new edg u v function df travers 
use bccutil void bcc int disc new int v int low new int v int parent new int v linkedlist edg st new linkedlist edg initi disc low parent array int 0 v disc 1 low 1 parent 1 int 0 v disc 1 bccutil disc low st parent int j 0 stack empti pop edg stack st size 0 j 1 system print st getlast u st getlast v st removelast j 1 system println count public static void main string arg graph g new graph 12 g addedg 0 1 g addedg 1 0 g addedg 1 2 g addedg 2 1 g addedg 1 3 g addedg 3 1 g addedg 2 3 g addedg 3 2 g addedg 2 4 g addedg 4 2 g addedg 3 4 g addedg 4 3 g addedg 1 5 g addedg 5 1 g addedg 0 6 g addedg 6 0 g addedg 5 6 g addedg 6 5 g addedg 5 7 g addedg 7 5 g addedg 5 8 g addedg 8 5 g addedg 7 8 g addedg 8 7 g addedg 8 9 g addedg 9 8 g addedg 10 11 g addedg 11 10 g bcc system println g count biconnect compon graph code contribut aakash hasija output 4 2 3 4 3 1 2 3 1 2 8 9 8 5 7 8 5 7 6 0 5 6 1 5 0 1 10 11 5 biconnect compon graph articl contribut anurag singh 
pleas write comment find anyth incorrect want share inform topic discuss adsbygoogl window adsbygoogl push compani wise code practic topic wise code practic 
